# Linux 基础

ARM Cortex-A7 使用32位指令集和32位地址空间

- 创建目录和子目录

>mkdir -p dir/dir 

- 拷贝

>cp -rfd dir_a dir_b 
d：如果源文件为链接文件，也只是把它作为链接文件复制过去，而不是复制实际文件

- 删除

>rm -rf dir_a 

- chmod：改变文件的权限

>chmod a+w .bashrc
chmod a-x .bashrc 增加或去除某种权限
>**+** 表示添加权限，**-**表示去除权限

tar xf xxx -C dir/xxx 提取文件, (-C 某个目录）

gedit 自带的图形文本编辑器

vi 配置：用户目录下添加 .vimrc文件

# Ubuntu 环境

安装 `git` `vsftpd` ` nfs-kernel-server` `rpcbind` `openssh-server`

可选工具 `neofetch` `ranger` `fzf` `zsh`

设置 *zsh* 为默认 shell

```sh
# 查看版本
zsh --version
# 设为默认
sudo chsh -s $(which zsh)
# 验证
echo $SHELL
```

使用 *wget* 安装 *oh-my-zsh* `sh -c "$(wget -O- https://install.ohmyz.sh/)"`

主题：*haoomz*（觉得不错）

插件：

>	zsh-autosuggestions： 一个命令提示插件 (apt安装)
>	zsh-syntax-highlighting ： 一个命令语法校验插件 (apt安装)
>	web-search ： 命令行跳转浏览器搜索（自带）

在配置文件 ~/.zshrc 中 找到 **plugins** 添加插件名称，找到 **ZSH_THEME** 修改主题

1. FTP

> sudo vi /etc/vsftpd.conf

取消注释
> local_enable=YES
> write_enable=YES

2. NFS

打开
> sudo vi /etc/exports

添加
> `/home/zuozhongkai/linux/nfs *(rw,sync,no_root_squash)`

## 安装 交叉编译器

1. [下载地址](https://developer.arm.com/downloads/-/gnu-a) 最下面是旧版的，更旧的版本可能需要百度找了。

2. 在 x86_64 Linux hosted cross compilers 平台下选择 *arm-none-linux-gnueabihf* 编译器 *.tar.xz* 类型的压缩包
![交叉编译器](STM32MP157环境搭建/tu1.png)

3. 下载解压到 */usr/local/arm/* (创建 arm 文件夹)

4. 添加到环境变量

- bash（默认）: 

```sh
# 打开文件
sudo vi /etc/profile
# 文件最后面添加，xxx 为解压后编译器文件夹的名字
export PATH=$PATH:/usr/local/arm/xxx/bin
```

- zsh :

在用户根目录下的 *.zshrc* 配置文件 添加 `export PATH=$PATH:/usr/local/arm/xxx/bin`

验证 `arm-none-linux-gnueabihf-gcc -v`

## VSCode和ST软件安装

1. [下载VSCode](https://code.visualstudio.com/)

下载 *.deb* 后缀的安装包

- 使用 apt 安装：进入下载目录执行 `sudo apt install ./xxx.deb` , xxx为下载的安装包名
- 使用 dpkg 安装 : `sudo dpkg -i xxx.deb`

2. 插件

>C/C++				 	这个肯定是必须的。
>C/C++ Snippets		 	C/C++重用代码块。
>C/C++ Advanced Lint 	C/C++静态检测 。
>Code Runner		 	代码运行。
>Include AutoComplete	自动头文件包含。
>Rainbow Brackets		彩虹花括号，有助于阅读代码。
>One Dark Pro			VSCode 的主题。
>GBKtoUTF8				将 GBK 转换为 UTF8。
>ARM				支持 ARM 汇编语法高亮显示。
>Chinese(Simplified)	中文环境。
>vscode-icons			VSCode 图标插件
>compareit				比较插件，可以用于比较两个文件的差异。
>DeviceTree				设备树语法插件。
>TabNine		一款 AI 自动补全插件，强烈推荐，谁用谁知道！

3. [下载STM32CubeProgrammer](https://www.st.com.cn/zh/development-tools/stm32cubeprog.html)

获取软件选择 'STM32CubePrg-Lin' 需要登录下载，

下载后解压 `unzip xxx.zip` 后运行 `./xxx.linux` 的文件

> 之后还安装了下面的库
> sudo apt-get install libusb-1.0.0-dev

4. USB DFU 以及 STLink 驱动安装

进入 STM32CubeProgrammer 安装路径下的 */Drivers/rules* 
执行 `sudo cp *.rules /etc/udev/rules.d/`
即拷贝 *.rules* 后缀的文件到 */etc/udev/rules.d/*

**验证** 插入 stlink 设备可在 */dev/* 目录下查看


## STM32MP1启动


### 一、安全启动（一般）

1. 首先 ROM 代码从选定的 Flash 设备中加载 FSBL 镜像文件(有头部信息)， FSBL 镜像就是 ROM 加载的第一个用户编写的可执行程序，一般是 TF-A 镜像。

2. FSBL 镜像加载以后需要对其进行鉴权

3. 鉴权成功，那么就会跳转到 FSBL 镜像入口地址，开始运行 FSBL 固件

### 二、串行启动

1. USB 启动

通过 USB OTG 接口来向 STM32MP1 烧写系统

2. UART 启动

通过 UART 烧写系统

### Flash 设备启动要求

	官方的 Flash 分区建议

| 尺寸          | 分区       | 描述      |
|--------------|------------|-----------|
| 256KB~512KB | fsbl     | 第一阶段启动代码，此分区存放 TF-A 或者 uboot 的 SPL 部分，<br> 如果写 A7 裸机例程的话此分区也用来存放裸机代码。 |
| 2MB         | ssbl     | 第二阶段启动代码， 一般是 uboot，如果 uboot 使用设备树的话,<br> 设备树添加到后面。 |
| 64MB        | bootfs   | boot 文件分区，可以存放如下内容：<br> · init ram 文件系统，可以将此文件系统拷贝到 RAM 中，<br> 在 linux 内核挂载正式根文件系统之前可以使用 init ram文件系统。<br> · linux 内核设备树<br> ·    linux 内核<br> · uboot 显示的启动界面<br> · uboot 发行配置文件 extlinux.conf |
| 16MB        | vendorfs | 此分区存放第三方的版权信息，确保它们不会受到任何<br> 开源许可的污染，比如 GPL V3。 |
| 768MB       | rootfs   | linux 根文件系统。 |
| 剩余空间     | userfs   | 用户自行使用的剩余空间 |

### STM23MP1 Linux系统启动过程

![STM32MP1Linux启动流程](STM32MP157环境搭建/STM32MP1Linux启动流程.png)

1. ROM 代码

> ST 自己编写的代码，ROM 代码作为第一链，首先要对 FSBL 代码进行鉴权，同样的， FSBL 以及后面的每一链都要对下一个阶段的镜像进行鉴权，直到设备系统正确启动。

2. FSBL

> FSBL 代码初始化时钟树、初始化外部 RAM 控制器，也就是 DDR。最终 FSBL 将 SSBL 加载到 DDR 里面并运行 SSBL 代码。
> 一般 FSBL 代码是 TF-A 或者 Uboot 的 SPL 代码，也可以将 FSBL 换成内核裸机代码

3. SSBL

> SSBL 代码运行在 DDR 里面，无需担心空间不够，一般是 Uboot，用来启动 Linux 内核

4. Linux 内核

> Linux 内核启动过程中会初始化板子上的各种外设

5. Linux 用户空间

> 系统启动的时候会通过 init 进程切换到用户空间，在这个过程中会初始化根文件系统里面的各种框架以及服务。

# tf-a

## 准备

- 打补丁
进到tf-a源码目录执行
```sh
for p in `ls -1 ../*.patch`; do patch -p1 < $p; done
```

- 使用自己的交叉编译器
打开 Makefile.sdk， 找到`CROSS_COMPILE`，将其改为“arm-none-linux-gnueabihf-”


- 编译需要的工具：
[stm32wrapper4dbg](https://github.com/STMicroelectronics/stm32wrapper4dbg/)
`stm32image`

## 移植

### 创建自己的设备树

tf-a源码\fdts 中的 
```sh
cp stm32mp157d-ed1.dts stm32mp157d-atk.dts
cp stm32mp15xx-edx.dtsi stm32mp157d-atk.dtsi
```
修改 stm32mp157d-atk.dts 为
`#include "stm32mp157d-atk.dtsi"`

`TFA_DEVICETREE` 配置项中添加 “stm32mp157d-atk”

### 修改电源管理和 TF 卡、 EMMC 设备树

#### stm32mp157datk.dtsi文件修改:

- 删除 pmic
- 删除vin节点，用下面内容替换
```sh
vddcore: regulator-vddcore {
	compatible = "regulator-fixed";
	regulator-name = "vddcore";
	regulator-min-microvolt = <1200000>;
	regulator-max-microvolt = <1350000>;
	regulator-off-in-suspend;
	regulator-always-on;
};

v3v3: regulator-3p3v {
	compatible = "regulator-fixed";
	regulator-name = "v3v3";
	regulator-min-microvolt = <3300000>;
	regulator-max-microvolt = <3300000>;
	regulator-off-in-suspend;
	regulator-always-on;
};

vdd: regulator-vdd {
	compatible = "regulator-fixed";
	regulator-name = "vdd";
	regulator-min-microvolt = <3300000>;
	regulator-max-microvolt = <3300000>;
	regulator-off-in-suspend;
	regulator-always-on;
};

vdd_usb: regulator-vdd-usb {
	compatible = "regulator-fixed";
	regulator-name = "vdd_usb";
	regulator-min-microvolt = <3300000>;
	regulator-max-microvolt = <3300000>;
	regulator-off-in-suspend;
	regulator-always-on;
};
```

*解释*： 
>	VDDCORE 电源，也就是 STM32MP157 的内核电源，最小为 1.2V，最大为 1.35V。
>	3.3V 电源，最小和最大都是 3.3V
>	VDD 电源，这是一个 3.3V 的电源，所以最小和最大都为 3.3V
>	VDD_USB 电源，为 3.3V，所以最小和最大都为 3.3V

- *sdmmc1* 和 *sdmmc2* 节点 替换：

```sh
&sdmmc1 {
	pinctrl-names = "default";
	pinctrl-0 = <&sdmmc1_b4_pins_a &sdmmc1_dir_pins_a>;
	st,neg-edge;
	broken-cd;
	bus-width = <4>;
	vmmc-supply = <&v3v3>;
	status = "okay";
};

&sdmmc2 {
	pinctrl-names = "default";
	pinctrl-0 = <&sdmmc2_b4_pins_a &sdmmc2_d47_pins_a>;
	non-removable;
	st,neg-edge;
	bus-width = <8>;
	vmmc-supply = <&v3v3>;
	vqmmc-supply = <&v3v3>;
	status = "okay";
};
```
- *usbotg_hs* 节点 替换

```sh
&usbotg_hs {
	phys = <&usbphyc_port1 0>;
	phy-names = "usb2-phy";
	usb-role-switch;
	status = "okay";
};

&usbphyc {
	status = "okay";
```

## xxx-serialboot.stm32 文件编译

此文件用于 **串行启动** 主要用于初始化 DDR，并且提供 USB 或串口功能，目的是为了进一步将 uboot 镜像下载到 DDR 的指定位置，最终通过 uboot 来向外部 flash 设备烧写整个系统镜像。

打开 Makefile.sdk 将 EXTRA_OEMAKE_SERIAL 改为
```Makefile
EXTRA_OEMAKE_SERIAL=$(filter-out STM32MP_SDMMC=1 STM32MP_EMMC=1 STM32MP_SPI_NOR=1 STM32MP_RAW_NAND=1 STM32MP_SPI_NAND=1,$(EXTRA_OEMAKE)) STM32MP_UART_PROGRAMMER=1 STM32MP_USB_PROGRAMMER=1
```
然后
```sh
make -f ../Makefile.sdk clean
make -f ../Makefile.sdk TFA_DEVICETREE=stm32mp157d-atk TF_A_CONFIG=serialboot ELF_DEBUG_ENABLE='1' all
```

在../build/serialboot 目录下生成