# 基础知识

## 字符设备驱动

![Linux 应用程序对驱动程序的调用流程](STM32MP157驱动笔记/STM32MP157驱动笔记0.png)

驱动加载成功以后会在“/dev”目录下生成一个相应的文件，应用程序通过对这个名为“/dev/xxx” (xxx 是具体的驱动文件名字)的文件进行相应的操作即可实现对硬件的操作。


在 Linux 内核文件 *include/linux/fs.h* 中有个叫做 file_operations 的结构体是 Linux 内核驱动操作函数集合

- *owner* 拥有该结构体的模块的指针，一般设置为 THIS_MODULE。
- *llseek* 函数用于修改文件当前的读写位置。
- *read* 函数用于读取设备文件。
- *write* 函数用于向设备文件写入(发送)数据。
- *poll* 是个轮询函数，用于查询设备是否可以进行非阻塞的读写。
- *unlocked_ioctl* 函数提供对于设备的控制功能，与应用程序中的 ioctl 函数对应。
- *compat_ioctl* 函数与 *unlocked_ioctl* 函数功能一样，区别在于在 64 位系统上，32 位的应用程序调用将会使用此函数。在 32 位的系统上运行 32 位的应用程序调用的是 *unlocked_ioctl*。
- *mmap* 函数用于将将设备的内存映射到进程空间中(也就是用户空间)，一般帧缓冲设备会使用此函数，比如 LCD 驱动的显存，将帧缓冲(LCD 显存)映射到用户空间中以后应用程序就可以直接操作显存了，这样就不用在用户空间和内核空间之间来回复制。
- *open* 函数用于打开设备文件。
- *release* 函数用于释放(关闭)设备文件，与应用程序中的 close 函数对应。
- *fasync* 函数用于刷新待处理的数据，用于将缓冲区中的数据刷新到磁盘中。

## 新字符设备驱动

## 设备树

## pinctrl和gpio子系统



# Linux 基础知识


## 并发与竞争

## 内核定时器

## 中断

## 阻塞和非阻塞IO

## 异步通知

# 基础知识Ⅱ

## platform

## INPUT子系统

## MISC驱动

# 设备篇

## PWM 设备&子系统

## 内核 RTC 驱动

## I2C 总线框架

## SPI 总线框架

## 串口驱动


## 块设备

## 网络设备驱动

### 有线网络

### 无线 WiFi 驱动

### 4G 通信

# 拓展

## Regmap 子系统

## IIO 驱动

## ADC驱动

## DAC驱动

## 单总线驱动

