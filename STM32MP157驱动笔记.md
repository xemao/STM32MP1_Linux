# 基础知识

## 字符设备驱动

![Linux 应用程序对驱动程序的调用流程](STM32MP157驱动笔记/STM32MP157驱动笔记0.png)

驱动加载成功以后会在“/dev”目录下生成一个相应的文件，应用程序通过对这个名为“/dev/xxx” (xxx 是具体的驱动文件名字)的文件进行相应的操作即可实现对硬件的操作。


> Linux 内核驱动操作函数集合： *file_operations* 的结构体，在 Linux 内核文件 *include/linux/fs.h* 中

- *owner* 拥有该结构体的模块的指针，一般设置为 THIS_MODULE。
- *llseek* 函数用于修改文件当前的读写位置。
- *read* 函数用于读取设备文件。
- *write* 函数用于向设备文件写入(发送)数据。
- *poll* 是个轮询函数，用于查询设备是否可以进行非阻塞的读写。
- *unlocked_ioctl* 函数提供对于设备的控制功能，与应用程序中的 ioctl 函数对应。
- *compat_ioctl* 函数与 *unlocked_ioctl* 函数功能一样，区别在于在 64 位系统上，32 位的应用程序调用将会使用此函数。在 32 位的系统上运行 32 位的应用程序调用的是 *unlocked_ioctl*。
- *mmap* 函数用于将将设备的内存映射到进程空间中(也就是用户空间)，一般帧缓冲设备会使用此函数，
    - 比如 LCD 驱动的显存，将帧缓冲(LCD 显存)映射到用户空间中以后应用程序就可以直接操作显存了，这样就不用在用户空间和内核空间之间来回复制。
- *open* 函数用于打开设备文件。
- *release* 函数用于释放(关闭)设备文件，与应用程序中的 close 函数对应。
- *fasync* 函数用于刷新待处理的数据，用于将缓冲区中的数据刷新到磁盘中。


### 开发步骤

1. 加载和卸载

```c
module_init(xxx_init); //注册模块加载函数
module_exit(xxx_exit); //注册模块卸载函数
```

> 使用 *modprobe* 命令加载驱动，调用 xxx_init 函数
> 使用 *rmmod* 命令卸载具体驱动，调用 xxx_exit 函数

*modprobe* 命令默认会去 */lib/modules/<kernel-version>* 目录中查找模块

2. 注册与注销

> 对于字符设备驱动而言，当*驱动模块加载*成功以后需要*注册字符设备*，同样，*卸载驱动模块*的时候也需要*注销掉字符设备*

注册和注销函数原型:

```c
static inline int register_chrdev(unsigned int major,
                                const char *name,
                                const struct file_operations *fops)
static inline void unregister_chrdev(unsigned int major,
                                    const char *name)
```

- *major*： **主设备号**， Linux 下每个设备都有一个设备号，设备号分为主设备号和次设备号两部分。
- *name*：**设备名字**，指向一串字符串。
- *fops*： 结构体 file_operations 类型指针，指向设备的**操作函数集合**变量。

需要选择没有被使用的主设备号，输入命令 `cat /proc/devices` 可以查看当前已经被使用掉的设备号

3. 实现设备的具体操作函数

分析一下需求

然后编写了四个函数： chrtest_open、 chrtest_read、chrtest_write 和 chrtest_release。这四个函数就是 chrtest 设备的 open、 read、 write 和 release 操作函数。

4. 添加 LICENSE 和作者信息

例如：

```c
MODULE_LICENSE("GPL");
MODULE_AUTHOR("xemao");
```

### Linux 设备号

为了方便管理， Linux 中每个设备都有一个设备号，设备号由主设备号和次设备号两部分组成

Linux 提供了一个名为 *dev_t* 的数据类型表示设备号， *dev_t* 定义在文件 *include/linux/types.h* 里面

```c
typedef __u32 __kernel_dev_t;
......
typedef __kernel_dev_t dev_t;
```

可以看出 *dev_t* 是 `__u32` 类型的，而 `__u32` 定义在文件 *include/uapi/asm-generic/int-ll64.h* 里面，定义如下：

```c
typedef unsigned int __u32;
```

*dev_t* 其实就是 `unsigned int` 类型，是一个 32 位的数据类型。这 32 位的数据构成了主设备号和次设备号两部分，其中高 12 位为主设备号，低 20 位为次设备号

在文件 *include/linux/kdev_t.h* 中提供了几个关于设备号的操作函数(本质是宏)

```c
#define MINORBITS 20
#define MINORMASK ((1U << MINORBITS) - 1)

#define MAJOR(dev) ((unsigned int) ((dev) >> MINORBITS))
#define MINOR(dev) ((unsigned int) ((dev) & MINORMASK))
#define MKDEV(ma,mi) (((ma) << MINORBITS) | (mi))
```

#### 动态分配设备号

```c
//分配设备号
int alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count, const char *name)
//释放设备号
void unregister_chrdev_region(dev_t from, unsigned count)
```

- *dev*：保存申请到的设备号。
- *baseminor*： 次设备号起始地址， `alloc_chrdev_region` 可以申请一段连续的多个设备号，这些设备号的主设备号一样，但是次设备号不同，次设备号以 baseminor 为起始地址地址开始递增。一般 baseminor 为 0，也就是说次设备号从 0 开始。
- *count*： 要申请的设备号数量
- *name*：设备名字
- *from*：要释放的设备号
- *count*： 表示从 from 开始，要释放的设备号数量

#### 补充

> 在内核中想要向控制台输出或显示一些内容，必须使用printk
> printk 可以根据日志级别对消息进行分类，一共有 8 个消息级别
> 这 8 个消息级别定义在文件 *include/linux/kern_levels.h* 里面

```c
#define KERN_SOH        "\001"
#define KERN_EMERG      KERN_SOH "0" /* 紧急事件，一般是内核崩溃 */
#define KERN_ALERT      KERN_SOH "1" /* 必须立即采取行动 */
#define KERN_CRIT       KERN_SOH "2" /* 临界条件，比如严重的软件或硬件错误*/
#define KERN_ERR        KERN_SOH "3" /* 错误状态，一般设备驱动程序中使用 KERN_ERR 报告硬件错误 */
#define KERN_WARNING    KERN_SOH "4" /* 警告信息，不会对系统造成严重影响 */
#define KERN_NOTICE     KERN_SOH "5" /* 有必要进行提示的一些信息 */
#define KERN_INFO       KERN_SOH "6" /* 提示性的信息 */
#define KERN_DEBUG      KERN_SOH "7" /* 调试信息 */
```

其中 0 的优先级最高， 7 的优先级最低。如果要设置消息级别，参考如下示例：

```c
printk(KERN_EMERG "gsmi: Log Shutdown Reason\n");
```

如果使用 printk 的时候不显式的设置消息级别，那么 printk 将会采用默认级别 `MESSAGE_LOGLEVEL_DEFAULT`

最终可以通过图形配置默认消息级别

```
-> Kernel hacking
    -> printk and dmesg options
        -> (7) Default console loglevel (1-15) //设置默认终端消息级别
        -> (4) Default message log level (1-7) //设置默认消息级别
```

*Default console loglevel* 默认为 7，意味着只有优先级高于 7 的消息才能显示在控制台上

而 MESSAGE_LOGLEVEL_DEFAULT 默认消息级别为 4， 4 的级别比 7 高，所示直接使用 printk 输出的信息是可以显示在控制台上的

编译驱动的 Makeflie 文件解释

```makefile
KERNELDIR := /home/zuozhongkai/linux/my_linux/linux-5.4.31
CURRENT_PATH := $(shell pwd)

obj-m := chrdevbase.o

build: kernel_modules

kernel_modules:
	$(MAKE) -C $(KERNELDIR) M=$(CURRENT_PATH) modules
clean:
	$(MAKE) -C $(KERNELDIR) M=$(CURRENT_PATH) clean
```

- KERNELDIR 表示开发板所使用的 Linux 内核源码目录，使用绝对路径
- CURRENT_PATH 表示当前路径，直接通过运行“pwd”命令来获取当前所处路径
- obj-m 表示将 chrdevbase.c 这个文件编译为 chrdevbase.ko 模块
- 具体的编译命令，
	- 后面的 modules 表示编译模块， 
	- -C 表示将当前的工作目录切换到指定目录中，也就是 KERNERLDIR 目录。 
	- M 表示模块源码目录，“make modules”命令中加入 M=dir 以后程序会自动到指定的 dir 目录中读取模块的源码并将其编译为.ko 文件

写好 makefile 文件直接输入 `make` 就可编译生成 xxx.ko 文件 这里是 chrdevbase.ko


### 测试

1. 加载

将 xxx.ko 就是设备的驱动模块拷贝到 */lib/modules/5.4.31* 目录下

输入 `depmod`命令以后会自动生成 一些 `modprobe` 所需的文件

然后使用 `modprobe` 加载 chrdevbase.ko

输入 `lsmod` 命令即可查看当前系统中存在的模块

输入如下 `cat /proc/devices` 命令查看当前系统中有没有 chrdevbase 这个设备

2. 驱动加载成功需要在 /dev 目录下创建一个与之对应的设备节点文件，应用程序就是通过操
作这个设备节点文件来完成对具体设备的操作。

```sh
mknod /dev/chrdevbase c 200 0
```

`mknod` 是创建节点命令，*/dev/chrdevbase* 是要创建的节点文件，*c*表示这是个字符设备，*200* 是设备的主设备号，*0* 是设备的次设备号

3. 卸载驱动模块

```sh
rmmod chrdevbase
```

使用 `lsmod` 查看 chrdevbase 这个模块还存不存在


## 新字符设备驱动

使用 Linux 内核推荐的新字符设备驱动API函数

### 一、分配和释放设备号

没有指定设备号的话就使用如下函数来申请设备号：

```c
int alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count, const char *name)
```

给定了设备的主设备号和次设备号就使用如下所示函数来注册设备号:

```c
int register_chrdev_region(dev_t from, unsigned count, const char *name)
```

>*from* 是要申请的起始设备号，也就是给定的设备号
>*count* 是要申请的数量，一般都是一个
>*name* 是设备名字

统一使用如下释放函数:

```c
void unregister_chrdev_region(dev_t from, unsigned count)
```

### 二、新的字符设备注册方法

1. 字符设备结构

使用 *cdev* 结构体表示一个字符设备， cdev 结构体在 *include/linux/cdev.h* 文件中的定义

在 cdev 中有两个重要的成员变量： `const struct file_operations *ops` 和 `dev_t dev`，这两个就是字符设备文件操作函数集合 **file_operations** 以及设备号 **dev_t**

编写字符设备驱动之前需要定义一个 cdev 结构体变量，这个变量就表示一个字符设备

例如：

```c
struct cdev test_cdev;
```

2. cdev_init 函数

定义好 *cdev* 变量以后就要使用 cdev_init 函数对其进行初始化， cdev_init 函数原型如下：

```c
void cdev_init(struct cdev *cdev, const struct file_operations *fops)
```

3. cdev_add 函数

cdev_add 函数用于向 Linux 系统添加字符设备(cdev 结构体变量)，cdev_add 函数原型如下：

```c
int cdev_add(struct cdev *p, dev_t dev, unsigned count)
```

4. cdev_del 函数

卸载驱动使用 cdev_del 函数从 Linux 内核中删除相应的字符设备， cdev_del函数原型如下：

```c
void cdev_del(struct cdev *p)
```

cdev_del 和 unregister_chrdev_region 这两个函数合起来的功能相当于 unregister_chrdev 函数


### 三、自动创建设备节点

使用 `modprobe` 加载驱动程序以后还需要使用命令 `mknod` 手动创建设备节点，在驱动中实现
自动创建设备节点的功能以后，使用 `modprobe` 加载驱动模块成功的话就会自动在 /dev 目录下
创建对应的设备文件。

1. 铺垫知识 mdev 机制

udev 是一个用户程序，在 Linux 下通过 udev 来实现设备文件的创建与删除， udev 可以检
测系统中硬件设备状态，可以根据系统中硬件设备状态来创建或者删除设备文件。比如使用
modprobe 命令成功加载驱动模块以后就自动在/dev 目录下创建对应的设备节点文件,使用
rmmod 命令卸载驱动模块以后就删除掉/dev 目录下的设备节点文件。在使用 buildroot 构建
根文件系统的时候选择了 udev 的简化版本 — *mdev*，所以在嵌入式 Linux 中我们使用 *mdev* 来实
现设备节点文件的自动创建与删除， Linux 系统中的热插拔事件也由 *mdev* 管理，如果使用
busybox 构建根文件系统，会在 /etc/init.d/rcS 文件中如下语句：

```sh
echo /sbin/mdev > /proc/sys/kernel/hotplug
```

上述命令设置热插拔事件由 mdev 来管理。 buildroot 构建的根文件系统再启动的时候会执行
*/etc/init.d/S10mdev* 脚本来启动 mdev

2. 创建和删除类

一般在 cdev_add 函数后面添加自动创建设备节点相关代码

首先要创建一个 class 类， class 是个结构体，定义在文件 *include/linux/device.h* 里面。 

**类创建函数**为 class_create， class_create 是个宏定义，将宏 class_create 展开以后内容如下：

```c
struct class *class_create (struct module *owner, const char *name)
```

> 参数 owner 一般为 THIS_MODULE
> 参数 name 是类名字。
> 返回值是个指向结构体 class 的指针，也就是创建的类。

卸载驱动程序的时候需要删除掉类，**类删除函数**为 class_destroy，函数原型如下：

```c
void class_destroy(struct class *cls);
```

> cls 就是要删除的类

3. 创建和删除设备

```c
struct device *device_create(struct class *cls,
                            struct device *parent,
                            dev_t devt,
                            void *drvdata,
                            const char *fmt, ...)
```

> 参数 cls 就是设备要创建哪个类下面
> 参数 parent 是父设备，一般为 NULL，也就是没有父设备
> 参数 devt 是设备号；
> 参数 drvdata 是设备可能会使用的一些数据，一般为 NULL
> 参数 fmt 是设备名字，如果设置 fmt=xxx 的话，就会生成 */dev/xxx* 这个设备文件。
> 返回值就是创建好的设备

```c
void device_destroy(struct class *cls, dev_t devt)
```
> 参数 classs 是要删除的设备所处的类
> 参数 devt 是要删除的设备号

### 四、设置文件私有数据

对于一个设备的所有属性信息我们最好将其做成一个结构体

编写驱动 open 函数的时候将设备结构体作为*私有数据*添加到设备文件中，如下

```c
/* 设备结构体 */
struct test_dev{
    dev_t devid;           /* 设备号 */
    struct cdev cdev;      /* cdev */
    struct class *class;   /* 类 */
    struct device *device; /* 设备 */
    int major;             /* 主设备号 */
    int minor;             /* 次设备号 */
};

struct test_dev testdev;

/* open 函数 */
static int test_open(struct inode *inode, struct file *filp)
{
    filp->private_data = &testdev; /* 设置私有数据 */
    return 0;
}
```


## 设备树


## pinctrl和gpio子系统

pinctrl 和 gpio 子系统就是驱动分离与分层思想下的产物

### 1 pinctrl 子系统

pinctrl 子系统主要工作内容如下：
1. 获取设备树中 pin 信息。
2. 根据获取到的 pin 信息来设置 pin 的复用功能
3. 根据获取到的 pin 信息来设置 pin 的电气特性

因此只需要在设备树里面**设置好某个 pin 的相关属性**即可，其他的初始化工作均由 pinctrl 子系统来完成， pinctrl 子系统源码目录为 *drivers/pinctrl*。

#### STM32MP1 的 PIN 配置信息详解

stm32mp15-pinctrl.dtsi 文件有 芯片的 pinctrl 节点配置

绑定文档 *Documentation/devicetree/bindings/pinctrl/st,stm32-pinctrl.yaml* 描述了如何在设备树中设置 STM32 的 PIN 信息

在 pins 子节点里面存放外设的引脚描述信息，这些信息包括：

1. pinmux 属性

`pinmux = <STM32_PINMUX('H', 13, AF9)>;`

使用 STM32_PINMUX 这宏来配置引脚和引脚的复用功能，定义在 *include/dt-bindings/pinctrl/stm32-pinfunc.h* 文件。

```c
#define PIN_NO(port, line) (((port) - 'A') * 0x10 + (line))

#define STM32_PINMUX(port, line, mode) (((PIN_NO(port, line)) << 8) | (mode))
```

属性：
- port：表示用那一组 GPIO(例： H 表示为 GPIO 第 H 组，也就是 GPIOH)。
- line：表示这组 GPIO 的第几个引脚(例： 13 表示为 GPIOH_13，也就是 PH13)
- mode： 表示当前引脚要做那种复用功能(例： AF9 表示为用第 9 个复用功能)

可配置的 mode（复用功能）定义在 stm32-pinfunc.h 文件里，除了配置项 AF0~AF9，还有 GPIO、 ANALOG 这两个。如果一个 PIN 只是作为最基本的 GPIO 功能，那么就是用“GPIO”；如果这个引脚要用作模拟功能，那
么就设置为“ANALOG”。

2. 电气属性配置

在 pinctrl 子系统里*电气特性不是必须*的，但是 *pinmux 属性是必须*要设置的


| 电气特性属性      | 类型      | 作用                          |
|------------------|:--------:|-------------------------------|
| bias-disable     | bootlean | 禁止使用內部偏置电压             |
| bias-pull-down   | bootlean | 内部下拉                        |
| bias-pull-up     | bootlean | 内部上拉                        |
| drive-push-pull  | bootlean | 推挽输出                        |
| drive-open-drain | bootlean | 开漏输出                        |
| output-low       | bootlean | 输出低电平                       |
| output-high      | bootlean | 输出高电平                       |
| slew-rate        | enum     | 引脚的速度，可设置： 0~3，<br> 0 最慢， 3 最高。 |

对于 STM32MP1 而言，如果一个 *IO 用作 GPIO* 功能的时候**不需要创建对应的 pinctrl 节点**！

### 2 gpio 子系统

用于初始化 GPIO 并且提供相应的 API 函数

#### STM32MP1 的 gpio 子系统驱动

以 PI0 这个引脚所在的 GPIOI 为例，打开 stm32mp151.dtsi，在里面找到如下所示内容：

```php
gpioi: gpio@5000a000 {
    gpio-controller;
    #gpio-cells = <2>;
    interrupt-controller;
    #interrupt-cells = <2>;
    reg = <0x8000 0x400>;
    clocks = <&rcc GPIOI>;
    st,bank-name = "GPIOI";
    status = "disabled";
};
```

文档 *Documentation/devicetree/bindings/gpio/gpio.txt* 详细描述了 gpio 控制器节点各个属性信息

`gpio-controller` 表示 gpioi 节点是个 GPIO 控制器，每个 GPIO 控制器节点必须包含“gpio-controller”属性。

`#gpio-cells` 属性和 `#address-cells` 类似， `#gpio-cells` 应该为 2，表示一共有两个 cell，第一个 cell 为 *GPIO 编号*，比如“&gpioi 0”就表示 PI0。第二个 cell 表示 *GPIO 极性*，如果为 0(GPIO_ACTIVE_HIGH)的话表示高电平有效，如果为 1(GPIO_ACTIVE_LOW)的话表示低电平有效。

`reg` 属性设置了 GPIOI 控制器的寄存器基地址偏移为 0X800。

`clocks` 属性指定这个 GPIOI 控制器的时钟。

#### gpio 子系统 API 函数

1. 申请 GPIO 管脚    **gpio_request**
2. 释放 GPIO 引脚    **gpio_free**
3. 设置某个 GPIO 为输入    **gpio_direction_input**
4. 设置某个 GPIO 为输出，并且设置默认输出值  **gpio_direction_output**
5. 获取某个 GPIO 的值   **gpio_get_value**
6. 设置某个 GPIO 的值   **gpio_set_value**

#### 与 gpio 相关的 OF 函数

1. of_gpio_named_count

用于获取设备树某个属性里面定义了几个 GPIO 信息，空的 GPIO 信息也会被统计到

2. of_gpio_count

和 of_gpio_named_count 函数一样，但统计的是 `gpios` 这个属性的 GPIO 数量

3. of_get_named_gpio

获取 GPIO 编号

```c
int of_get_named_gpio(struct device_node *np,
                    const char *propname,
                    int index)
```

np：设备节点。
propname：包含要获取 GPIO 信息的属性名。
index： GPIO 索引，因为一个属性里面可能包含多个 GPIO，此参数指定要获取哪个 GPIO的编号，如果只有一个 GPIO 信息的话此参数为 0

### 3 实验程序编写

在 stm32mp157d-atk.dts 文件的根节点“/”下创建 LED 灯节点，节点名为 `gpioled`，节点内容如下：

```c
gpioled {
    compatible = "alientek,led";
    status = "okay";
    led-gpio = <&gpioi 0 GPIO_ACTIVE_LOW>;
};
```
新建 gpioled.c 文件 编写驱动


# Linux 基础知识



# 基础知识Ⅱ

## platform

## INPUT子系统

## MISC驱动

# 设备篇

## PWM 设备&子系统

## 内核 RTC 驱动

## I2C 总线框架

## SPI 总线框架

## 串口驱动


## 块设备

## 网络设备驱动

### 有线网络

### 无线 WiFi 驱动

### 4G 通信

# 拓展

## Regmap 子系统

## IIO 驱动

## ADC驱动

## DAC驱动

## 单总线驱动

驱动目录
/lib/modules/5.4.31 
设备树
/proc/devicetree
查看注册的中断
cat /proc/interrupts
platform 驱动模块加载完成以后查看驱动是否存在的目录
/sys/bus/platform/drivers/
注册input类时的文件目录
/sys/class/input

异步通知的核心就是信号
在 arch/xtensa/include/uapi/asm/signal.h 文件中定义了 Linux 所支持的所有信号